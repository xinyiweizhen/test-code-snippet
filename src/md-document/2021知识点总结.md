

[TOC]

### CSS

1. ##### CSS 有哪些选择器？选择器的优先级？

   | 选择器     | 语法       | 例子                             |
   | ---------- | ---------- | -------------------------------- |
   | 通用选择器 | *          | -                                |
   | 类型选择器 | 节点名称   | `div`                            |
   | ID 选择器  | # + ID 名  | `#form`                          |
   | 类选择器   | . + 类名   | `.btn-primary`                   |
   | 属性选择器 | [属性名]   | `[self]`、`[data-type="hidden"]` |
   | 伪类       | :伪类名    | `:hover`、`:focus`               |
   | 伪元素     | ::伪元素名 | `::before`、`::after`            |
   
   权重表：
   
   | 权重 | 选择器               |
   | ---- | -------------------- |
   | 1000 | 内联                 |
   | 0100 | ID 选择器            |
   | 0010 | 类、属性、伪类选择器 |
   | 0001 | 标签、伪元素         |
   
   总的来说，就是：
   
   **内联 > id 选择器 > 类、属性、伪类选择器 > 标签元素、伪元素**
   
   还有更复杂的优先级说明详见参考链接
   
   [[ 面试系列 ] - 八：说一下 CSS 选择器优先级](https://juejin.cn/post/6844904128364150797)
   
2. ##### 常见的结构布局

   - [全背景下等宽内容居中](https://lhammer.cn/You-need-to-know-css/#/zh-cn/fluid-fixed?id=全背景下等宽内容居中)

     将元素左右padding设置为父元素宽度的50%减去等宽内容的一半即可，无需设置width

     > 背景知识：👉[calc()](https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc)

     ```css
     .main > header,
     .main > section,
     .main > footer{
       padding: 16px calc(50% - 600px);
      }
     ```

     [全背景下等宽内容居中 - codepen在线编辑](https://codepen.io/yaounder/pen/yLgodxG)

     ![](https://raw.githubusercontent.com/xinyiweizhen/ImageGallery/main/blog_img/20210407095451.png)

   - [绝对底部](https://lhammer.cn/You-need-to-know-css/#/zh-cn/sticky-footer)（页脚紧贴在视口的最底部）

     如果页面内容不足够长时，页脚紧贴在视口的最底部；如果内容足够长时，页脚紧跟在内容的下方。

     > 背景知识：👉[calc()](https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc), 👉[flex](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex)
     >
     > 利用计算函数 `calc()` 计算（视窗高度 - 页头高度 - 页脚高度）赋予内容区最小高度

     ```css
     section {
         box-sizing: border-box;
         min-height: calc(100% - 59px - 107px);
       }
     ```

     [绝对底部 - codepen在线编辑](https://codepen.io/yaounder/pen/OJprXaE)

   - [圣杯布局](https://lhammer.cn/You-need-to-know-css/#/zh-cn/holy-grail-layout?v=1)（两边等宽，中间自适应）

     ```css
     section {
       /* 流出左右两边的位置 */
       padding: 0 100px;
       box-shadow: 0 0 0 1px #eee;
      }
       section::after {
         content: '';
         display: block;
         clear: both;
       }
       section > div {
         height: 229px;
         line-height: 1.5em;
         text-align: center;
           /* 利用浮动 */
         float: left;
         color: white;
         background: #b4a078;
       }
       section .left, section .right {
         position: relative;
           /* 左右两边的宽度 */
         width: 100px;
       }
       section .left {
         left: -100px;
         margin-left: -100%;
         background: #b4a000;
       }
       section .center {
           /* 中间宽度自适应 */
         width: 100%;
         text-align: justify;
         hyphens: auto;
       }
       section .right {
         left: 100px;
         margin-left: -100px;
          background: #b4a0ff;
       }
     ```

     

     [圣杯布局 - codepen在线编辑](https://codepen.io/yaounder/pen/xxqmRoo)

     [CSS之圣杯布局与双飞翼布局](https://juejin.cn/post/6973562604581027853)

   - [双飞翼布局](https://lhammer.cn/You-need-to-know-css/#/zh-cn/double-wing-layout?v=1)（两边等宽，中间自适应的三栏布局）

   - [类订单布局](https://lhammer.cn/You-need-to-know-css/#/zh-cn/class-order-layout)（左侧高度不固定，右侧自适应高度并且居中）
   
   优秀参考资源：
   
   ​	[You-need-to-know-css](https://lhammer.cn/You-need-to-know-css/#/zh-cn/)
   
   ​	[几种常见的CSS布局](https://juejin.cn/post/6844903710070407182#heading-1)
   
3. ##### BFC概念？作用？常用场景？

   **概念**

   >  BFC 即 Block Formatting Contexts (块级格式化上下文). 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

   **触发 BFC**

   只要元素满足下面任一条件即可触发 BFC 特性：[MDN创建块格式化上下文的方式](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)

   - HTML 就是一个 BFC
   - 浮动元素：float 除`none` 以外的值
   - 绝对定位元素：position (`absolute`、`fixed`)
   - display 为` inline-block`、`table-cells`、`flex`
   - overflow 除了` visible `以外的值 (`hidden`、`auto`、`scroll`)

   **BFC 特性及应用**

   - 同一个 BFC 下外边距会发生重叠
   - BFC 可以包含浮动的元素（清除浮动）
   - BFC 不与浮动元素重叠

   [10 分钟理解 BFC 原理](https://zhuanlan.zhihu.com/p/25321647)

   [面试官：请说说什么是BFC？大白话讲清楚](https://juejin.cn/post/6950082193632788493)

4. ##### 盒模型概念，如何切换盒模型？

   

   CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：`外边距（margin）`、`边框（border）`、`内边距（padding）`、`实际内容（content）`四个属性。

   CSS盒模型有：**标准模型 + IE模型**

   **标准盒模型**和**IE盒模型**的区别在于设置`width`和`height`时，所对应的范围不同：

   - **标准盒模型的`width`和`height`属性的范围只包含了`content`**
   - **IE盒模型的`width`和`height`属性的范围包含了`border`、`padding`和`content`**

   **W3C盒子模型(标准盒模型)**

   标准盒模型：盒子总宽度/高度 = `width/height + padding + border + margin`。（ 即 width/height 只是**内容高度**，不包含 padding 和 border 值）

   ![标准盒模型](https://pic1.zhimg.com/80/v2-ad08059be04698f8a70d2729cea8ec18_720w.jpg)

   **IE盒子模型(怪异盒模型)**

   IE盒子模型：盒子总宽度/高度 = `width/height + margin = (内容区宽度/高度 + padding + border) + margin`。（ 即 width/height 包含了 padding 和 border 值 ）

   ![怪异盒模型](https://pic3.zhimg.com/80/v2-d755200d4f64ca2463b75375a2b47d26_720w.jpg)

   **设置这两种模型**(`box-sizing`)

   ```
   标准：box-sizing: content-box; ( 浏览器默认设置 )
   IE： box-sizing: border-box;
   ```

   [常见的面试问题：【CSS】CSS盒模型](https://zhuanlan.zhihu.com/p/74817089)

   [CSS盒模型完整介绍](https://segmentfault.com/a/1190000013069516)

   [对盒模型的理解](https://juejin.cn/post/6905539198107942919#heading-12)

5. ##### 伪类和伪元素区别？使用场景？

   - **伪类**

     **伪类存在的意义是为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的信息。**

     

     <img src="https://pic2.zhimg.com/v2-a85036113478c3bc36062f76ef8e66bd_r.jpg" alt="伪类"  />

     

     伪类的使用场景有：

     1. 格式化DOM树以外的信息。比如： 标签的:link、:visited 等。这些信息不存在于DOM树中。
     2. 不能被常规CSS选择器获取到的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。

     

   - **伪元素**

     **伪元素可以创建一些文档语言无法创建的虚拟元素**。比如：文档语言没有一种机制可以描述元素内容的第一个字母或第一行，但伪元素可以做到(::first-letter、::first-line)。同时，伪元素还可以创建源文档不存在的内容，比如使用 ::before 或 ::after。

     

     ![伪元素](https://pic4.zhimg.com/80/v2-e44eab840072dc00011854928fb0bcaf_720w.jpg)

     伪元素的使用场景：

     1. 清楚浮动。

   [伪类和伪元素](https://juejin.cn/post/6844903929289900046)

   [了解css中伪元素 before和after的用法](https://juejin.cn/post/6844903805193027592)

   [CSS 伪元素的一些罕见用例](https://juejin.cn/post/6844904163625697293)

   

6. ##### 水平垂直居中？兼容性？不知道宽高情况下？

   分两大类：子元素已知宽高和子元素未知宽高

   - **已知宽高**

     - 绝对定位和负margin值

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           position: relative;
       }
       .children-box {
           position: absolute;
           width: 100px;
           height: 100px;
           background: yellow;
           left: 50%;
           top: 50%;
           margin-left: -50px;
           margin-top: -50px; 
       }
       ```

     - 绝对定位 + transform(子元素未知宽高也可用)

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           position: relative;
       }
       .children-box {
           position: absolute;
           width: 100px;
           height: 100px;
           background: yellow;
           left: 50%;
           top: 50%;
           transform: translate(-50%, -50%); 
       }
       ```

     - 绝对定位 + left/right/bottom/top + margin

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           position: relative;
       }
       .children-box {
           position: absolute;
           display: inline;
           top: 0;
           left: 0;
           right: 0;
           bottom: 0px;
           background: yellow;
           margin: auto;
           height: 100px;
           width: 100px;
       }
       ```

     - flex布局(子元素未知宽高也可用, 只需设置父元素，可惜PC端兼容性不太友好)

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: flex;
           justify-content: center;
           align-items: center;
       }
       .children-box {
           background: yellow;
           height: 100px;
           width: 100px;
       }
       ```

     - grid布局

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: grid;
       }
       .children-box {
           width: 100px;
           height: 100px;
           background: yellow;
           margin: auto;
       }
       ```

     - table-cell + vertical-align + inline-block/margin: auto

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: table-cell;
           text-align: center;
           vertical-align: middle;
       }
       .children-box {
           width: 100px;
           height: 100px;
           background: yellow;
           display: inline-block;// 可以换成margin: auto;
       }
       ```

   - **不定宽高**

     - 绝对定位 + transform

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           position: relative;
       }
       .children-box {
          position: absolute;
          background: yellow;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
       }
       ```

       

     - table-cell

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: table-cell;
           text-align: center;
           vertical-align: middle;
       }
       .children-box {
          background: yellow;
          display: inline-block;
       }
       ```

       

     - flex布局

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: flex;
           justify-content: center;
           align-items: center;
       }
       .children-box {
           background: yellow;
       }
       ```

       

     - flex变异布局

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: flex;
       }
       .children-box {
           background: yellow;
           margin: auto;
       }
       ```

       

     - grid + flex布局

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: grid;
       }
       .children-box {
           background: yellow;
           align-self: center;
           justify-self: center;
       }
       ```

       

     - gird + margin布局

       ```css
       .box {
           width: 200px;
           height: 200px;
           border: 1px solid red;
           display: grid;
       }
       .children-box {
           background: yellow;
           margin: auto;
       }
       ```

   [水平垂直居中的布局（定宽高和不定宽高](https://zhuanlan.zhihu.com/p/89197310)

   [如何让一个元素水平垂直居中](https://zhuanlan.zhihu.com/p/113341088)

   [面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高](https://juejin.cn/post/6844903982960214029#heading-17)

7. ##### Flex 怎么用，常用属性有哪些？

   - 开启flex布局

     只需要在父级元素上写上`display: flex;`

     ```css
     #dad{   
     display: flex; 
     } 
     //行内元素也可以 
     #dad{   
     display: inline-flex; 
     } 
     //Webkit内核的浏览器，需加上前缀 
     #dad{  
      display: -webkit-flex;
     }
     ```

   - 常用属性

     - 父容器上的属性

       1. 设置**主轴**的方向：`flex-direction`

          可选值：

          > `row`: 默认值，主轴为水平方向从左到右；
          >
          > `row-reverse`: 主轴为水平方向从右到左；
          >
          > `column`: 主轴为垂直方向从上到下；
          >
          > `column-reverse`: 主轴为垂直方向从下到上

       2. 设置子容器沿**主轴**排列：`justify-content`

          可选值：

          >位置排列：
          >
          >​	`flex-start`  起始端对齐
          >
          >​	`flex-end ` 末尾段对齐
          >
          >​	`center ` 居中对齐
          >
          >分布排列：
          >
          >​	`space-between `  子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切
          >
          >​	`space-around` 子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半

       3. 设置子容器如何沿**交叉轴**排列：`align-items`

          可选值：

          > 位置排列：
          >
          > ​	`flex-start ` 起始端对齐
          >
          > ​	`flex-end ` 末尾段对齐
          >
          > ​	`center` 居中对齐
          >
          > 基线排列：
          >
          > ​	`baseline` 基线对齐，这里的`baseline`默认是指首行文字，即`first baseline`，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线
          >
          > 拉伸排列：
          >
          > ​	`stretch` 子容器沿交叉轴方向的尺寸拉伸至与父容器一致

       4. 设置换行方式：`flex-wrap`

          可选值：

          >不换行：`nowrap`
          >
          >换行：`wrap`
          >
          >反向换行：`wrap-reverse`

     - 子容器上的属性

       1. 属性定义项目的排列顺序 `order`

           `order` 数值越小，排列越靠前，默认为0

       2. 属性定义项目的放大比例 `flex-grow`

          默认为`0`，即如果存在剩余空间，也不放大

          如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

       3. 定义项目的缩小比例 `flex-shrink`

          默认为1，即如果空间不足，该项目将缩小。

          如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。

       4. 定义在分配多余空间之前，项目占据的主轴空间（main size）`flex-basis`

          `flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。

          它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。

       5. `flex`

          `flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto` 后两个属性可选。

          该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。

          建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

       6. 允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性 `align-self`

          该属性可能取6个值，除了auto，其他都与align-items属性完全一致。

   [flex 怎么用，常用属性有哪些？](https://zhuanlan.zhihu.com/p/68661702)

   [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

   [Flex布局演示站](https://xluos.github.io/demo/flexbox/)

8. ##### position的 `absolute` 与 `fixed` 共同点与不同点

   共同点： 改变行内元素的呈现方式，`display`被置为`block` 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上。

   不同点： `absolute`的 “根元素（父元素）”是可以设置的， `fixed`的 “根元素（父元素）”固定为浏览器窗口，只针对浏览器窗口定位。当你滚动网页，`fixed`元素与浏览器窗口之间的距离是不变的。

9. ##### `transition` 和 `animation` 的区别

   `animation` 和 `transition` 大部分属性是相同的，他们都是随时间改变元素的属性值。

   **主要区别**:

   ​	 `transition` 需要触发一个事件才能改变属性， 而 `animation` 不需要触发任何事件的情况下才会随时间改变属性值，并且`transition`为2帧，从`from .... to`，而`animation`通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。

   **参数**：

   `transition`： 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始 

   `animation`： 指定要绑定到选择器的关键帧的名称

   

10. #####  `display`的`block`、`inline`和`inline-block`的区别

   （1）**`block`：** **会独占一行，多个元素会另起一行，可以设置`width`、`height`、`margin`和`padding`属性；**

   （2）**`inline`：** **元素不会独占一行，设置width、height属性无效。**但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；

   （3）**inline-block：** **将对象设置为inline对象，但对象的内容作为block对象呈现**，**之后的内联对象会被排列在同一行内。**

   对于行内元素和块级元素，其特点如下：

   **（1）行内元素**

   - 设置宽高无效；
   - 可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；
   - 不会自动换行；

   **（2）块级元素**

   - 可以设置宽高；
   - 设置margin和padding都有效；
   - 可以自动换行；
   - 多个块状，默认排列从上到下。

11. ##### 回流（reflow）与重绘(reprint)的概念

    **什么是回流(重排)：**

    当render tree中的一部分(或全部)因为元素的**规模尺寸，布局，隐藏**（几何属性）等改变而需要**重新构建**。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

    ![回流过程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ce7cc5fda4b46a7b778aaa5b35e7fac~tplv-k3u1fbpfcp-zoom-1.image)

    相当于将解析和合成的过程重新又走了一遍，开销是非常大的。

    

    **什么是重绘：**

     当render tree中的一些元素需要**更新属性**，而这些属性**只是影响元素的外观，风格，而不会影响布局的**，比如background-color。则就叫称为重绘。

    ![重绘](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ccb378cd43047c0a1d7d56a175bb0bd~tplv-k3u1fbpfcp-zoom-1.image)

    跳过了`生成布局树`和`建图层树`的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。

    **区别：**

     **回流必将引起重绘，而重绘不一定会引起回流**。比如：只有颜色改变的时候就只会发生重绘而不会引起回流当页面布局和几何属性改变时就需要回流，比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

    

    **⼏何属性**：包括布局、尺⼨等可⽤数学⼏何衡量的属性

    - 布局： display 、 float 、 position 、 list 、 table 、 flex 、 columns 、 grid
    - 尺⼨： margin 、 padding 、 border 、 width 、 height

    **外观属性**：包括界⾯、⽂字等可⽤状态向量描述的属性

    - 界⾯： appearance 、 outline 、 background 、 mask 、 box-shadow 、 box-reflect 、
      filter 、 opacity 、 clip
    - ⽂字： text 、 font 、 word  

    

    [什么是重绘和重排？ 如何去避免？](https://juejin.cn/post/6976644294740279310)

12. ##### offsetWidth、 clientWidth、 scrollWidth 、width，那它们有什么区别 ?

    1. **[offsetWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetWidth)**

       **`HTMLElement.offsetWidth`** 是一个只读属性，返回一个元素的布局宽度。一个典型的（各浏览器的`offsetWidth`可能有所不同）`offsetWidth`是测量**包含**元素的边框(`border`)、水平线上的内边距(`padding`)、竖直方向滚动条(`scrollbar`如果存在的话）、以及CSS设置的宽度(`width`)的值。

       > 这个属性将会 round(四舍五入)为一个整数。如果你想要一个小数值,请使用[`element.getBoundingClientRect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect).

       ![offsetWidth](https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png)

    2. **[clientWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientWidth)**

       **HTMLElement.clientWidth** 属性表示元素的内部宽度，以像素计， 是一个只读属性。**内联元素以及没有 CSS 样式的元素的 `clientWidth` 属性值为 0。**`clientWidth` 该属性**包括**水平线上的内边距(`padding`)，但**不包括**垂直滚动条(`scrollbar`如果存在的话）、边框(`border`)和外边距(`margin`)。

       > 该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 [`element.getBoundingClientRect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)。

       ![clientWidth](https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png)

    3. **[scrollWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollWidth)**

       **Element.scrollWidth** 这个只读属性是元素内容宽度的一种度量，包括由于`overflow`溢出而在屏幕上不可见的内容。

       `scrollWidth`值等于元素在不使用水平滚动条的情况下适合视口中的所有内容所需的最小宽度。 宽度的测量方式与[`clientWidth`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientWidth)相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条（如果存在）。 它还可以包括伪元素的宽度，例如[`::before`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before)或[`::after`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after)。 如果元素的内容可以适合而不需要水平滚动条，则其`scrollWidth`等于[`clientWidth`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientWidth)

       > 1. 这个属性会进行四舍五入并返回整数，如果你需要小数形式的值，使用[`element.getBoundingClientRect()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect).
       > 2. 在实际测试过程中，谷歌获取的 **`Element.scrollWidth`** 和 IE，火狐下获取的 **`Element.scrollWidth`** 并不相同

    4. **[style.width](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width)**

       **`width`** 属性用于设置元素的宽度。`width` 默认设置[内容区域](https://developer.mozilla.org/en-US/docs/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model#content-area)的宽度，但如果 [`box-sizing`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing) 属性被设置为 `border-box`，就转而设置[边框区域](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model#border-area)的宽度。

       > [`min-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-width) 和 [`max-width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width) 属性的优先级高于 [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width)。

    [offsetWidth和它的兄弟姐妹们](https://zhuanlan.zhihu.com/p/83078754)

    [scrollWidth、clientWidth、offsetWidth、width的区别](https://www.jianshu.com/p/76ba0d71bd7c)

    [元素的视图属性之offset](https://zhuanlan.zhihu.com/p/55456162)

13. ##### getBoundingClientRect() 是什么？

    **Element.getBoundingClientRect()** 方法返回元素的大小及其相对于视口的位置。

    如果是标准盒子模型，元素的尺寸等于`width/height` + `padding` + `border-width`的总和。如果`box-sizing: border-box`，元素的的尺寸等于 `width/height`。

    

    返回值是一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，这个对象是由该元素的 [`getClientRects()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects) 方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。返回的结果是包含完整元素的最小矩形，并且拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`这几个以像素为单位的只读属性用于描述整个边框。除了`width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

    ![DOMRect 示例图](https://mdn.mozillademos.org/files/15087/rect.png)

    空边框盒（没有内容的边框）会被忽略。如果所有的元素边框都是空边框，那么这个矩形给该元素返回的 `width`、`height` 值为 0，`left`、`top` 值为第一个 CSS 盒子（按内容顺序)的 top-left 值。

    当计算边界矩形时，会考虑视口区域（或其他可滚动元素）内的滚动操作，也就是说，当滚动位置发生了改变，`top`和`left`属性值就会随之立即发生变化（因此，它们的值是相对于视口的，而不是绝对的）。如果你需要获得相对于整个网页左上角定位的属性值，那么只要给`top`、`left`属性值加上当前的滚动位置（通过` window.scrollX` 和 `window.scrollY`），这样就可以获取与当前的滚动位置无关的值。

    [Element.getBoundingClientRect() - MD](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)

14. 

15. 

    

    

### 移动端

1. ##### px、em、rem、vw、百分比的区别

   **px：**是固定单位，其他几种都是相对单位。当我们把电脑屏幕的分辨率调为1440*900时，css里设置的1px实际的物理尺寸就是屏幕宽度的1/1440。

   **em：**默认字体大小的倍数。比如给元素设置font-size: 2em，这里的默认字体大小实际上是继承自父亲的大小，font-size: 2em表示当前元素字体大小是父亲的2倍。当给元素设置width: 2em，这里的默认字体大小是该元素自身的实际字体大小。

   **rem：**根元素(html 节点)字体大小的倍数。比如一个元素设置 width: 2rem 表示该元素宽度为html节点的font-size 大小的2倍。 如果html未设置font-size的大小，默认是16px。

   **vw：**1vw 代表浏览器视口宽度的1%。

   **百分比：**对不同属性有不同的含义。 font-size: 200% 和font-size: 2em 一样，表示字体大小是默认（继承自父亲）字体大小的2倍。 line-height: 200% 表示行高是自己字体大小的2倍。 width: 100%表示自己content的宽度等于父亲content宽度的1倍。

2. ##### 移动端如何做适配有哪些方案 ?

   - viewport缩放方案
   - 动态rem方案
   - vw（百分比）适配方案

   [聊一聊移动端适配思路](https://zhuanlan.zhihu.com/p/338797235)

   [移动适配方案](https://github.com/xinyiweizhen/test-code-snippet/tree/master/src/test-mobile-layout)

### javascript

1. ##### JS有哪几种数据类型?

   简单：

   **原始类型**

   - `Null`：只包含一个值：`null`
   - `Undefined`：只包含一个值：`undefined`
   - `Boolean`：包含两个值：`true`和`false`
   - `Number`：整数或浮点数，还有一些特殊值（`-Infinity`、`+Infinity`、`NaN`）
   - `String`：一串表示文本值的字符序列
   - `Symbol`：一种实例是唯一且不可改变的数据类型

   (在`es10`中加入了第七种原始类型`BigInt`，现已被最新`Chrome`支持)

   **对象类型**

   - `Object`：自己分一类丝毫不过分，除了常用的`Object`，`Array`、`Function`等都属于特殊的对象

   详细：

   最新的 ECMAScript 标准定义了 9 种数据类型: 

   - [undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined):   `typeof instance === "undefined"`
   - [Boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean):  `typeof instance === "boolean"`
   - [Number](https://developer.mozilla.org/en-US/docs/Glossary/Number)：`typeof instance === "number"`
   - [String](https://developer.mozilla.org/en-US/docs/Glossary/String)：`typeof instance === "string`
   - [BigInt](https://developer.mozilla.org/en-US/docs/Glossary/BigInt)：`typeof instance === "bigint"` (ES10加的)
   - [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) ：`typeof instance === "symbol"`
   - [null](https://developer.mozilla.org/en-US/docs/Glossary/Null)：`typeof instance === "object"` Null 类型只有一个值： `null`.
   - [Object](https://developer.mozilla.org/en-US/docs/Glossary/Object)：`typeof instance === "object"`
   - [Function](https://developer.mozilla.org/en-US/docs/Glossary/Function)：非数据结构，尽管 typeof 操作的结果是：`typeof instance === "function"`

   `Symbol`和`BigInt`的使用场景：
      - `Symbol`的使用场景.
           - 防止XSS  在React的ReactElement对象中，有一个?typeof属性，它是一个Symbol类型的变量
           ```javascript
           var REACT_ELEMENT_TYPE =(typeof Symbol === 'function' && Symbol.for &&Symbol.for('react.element')) ||0xeac7;
           ```
           - 私有属性 借助Symbol类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写
           ```javascript
           const privateField = Symbol();
           class myClass {
           constructor(){
           this[privateField] = 'ConardLi';
               
           }
           getField(){
               return this[privateField];
           }
           setField(val){
               this[privateField] = val;
           }
           }
           ```
           - 防止属性污染 用Symbol作为对象属性可以保证永远不会出现同名属性。
           
           - `BigInt`的使用场景.
           
           - `BigInt`可以操作超过最大安全数字的数字. JavaScript中`Number.MAX_SAFE_INTEGER`表示最大安全数字,计算结果是`9007199254740991`，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是`1.111...X 2^52`。

   [MDN上的JavaScript 数据类型和数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)

   [【JS 进阶】你真的掌握变量和类型了吗](https://juejin.cn/post/6844903854882947080#heading-9)

2. ##### 变量声明提升？

   1. 变量声明提升

      大部分编程语言都是先声明变量再使用，但在 JS 中，使用`var`声明变量可以不一样：

      ```javascript
      console.log(a); // undefined
      var a = 10;
      ```

      上述代码正常输出`undefined`而不是报错`Uncaught ReferenceError: a is not defined`,这是因为声明提升（hoisting），相当于如下代码：

      ```javascript
         var a; //声明 默认值是undefined “准备工作”
         console.log(a);
         a = 10; //赋值
      ```

   2. 函数声明提升

       我们都知道，创建一个函数的方法有两种，一种是通过函数声明`function foo(){}` ,另一种是通过函数表达式`var foo = function(){}` ,那这两种在函数提升有什么区别呢？

      ```javascript
         console.log(f1); // function f1(){}
         function f1() {} // 函数声明
         console.log(f2); // undefined
         var f2 = function() {}; // 函数表达式
      ```

       接下来我们通过一个例子来说明这个问题：

      ```javascript
         function test() {
             foo(); // Uncaught TypeError "foo is not a function"
             bar(); // "this will run!"
             var foo = function() {
                 // function expression assigned to local variable 'foo'
                 alert("this won't run!");
             };
             function bar() {
                 // function declaration, given the name 'bar'
                 alert("this will run!");
             }
         }
         test();  // out: 
      ```

       在上面的例子中，`foo()`调用的时候报错了，而 bar 能够正常调用。

         我们前面说过变量和函数都会上升，遇到函数表达式 `var foo = function(){}`时，首先会将`var foo`上升到函数体顶部，然而此时的` foo` 的值为 `undefined`,所以执行`foo()`报错。

         而对于函数`bar()`, 则是提升了整个函数，所以`bar()`才能够顺利执行。

         有个细节必须注意：**当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。**

      ```javascript
      alert(a); //输出：function a(){ alert('我是函数') }
         function a() {
             alert("我是函数");
         } //
      var a = "我是变量";
      alert(a); //输出：'我是变量'
      ```

      ` function` 声明的优先级比`var` 声明高，也就意味着当两个同名变量同时被` function` 和 `var `声明时，`function `声明会覆盖` var` 声明。

      这代码等效于：

      ```javascript
      function a() {
        alert("我是函数");
      }
      var a; //hoisting
      alert(a); //输出：function a(){ alert('我是函数') }
      a = "我是变量"; //赋值
      alert(a); //输出：'我是变量'
      ```

      最后我们看个复杂点的例子：

      ```javascript
      function test(arg) {
             // 1. 形参 arg 是 "hi"
             // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function
             console.log(arg);
             var arg = "hello"; // 3.var arg 变量声明被忽略， arg = 'hello'被执行
             function arg() {
                 console.log("hello world");
             }
             console.log(arg);
         }
      test("hi");
      /* 输出：
      function arg(){
        console.log('hello world') 
      }
      hello 
      */
      ```

      这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：

         - 如果有形参，先给形参赋值

         - 进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，**但是可以重新赋值**

         - 私有作用域中的代码从上到下执行

           

3. ##### 什么是执行上下文（EC）? 执行上下文的生命周期？

   执行上下文就是当前 JavaScript 代码被解析和执行时所处环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行.

   在 JavaScript 代码运行时，解释执行全局代码、调用函数或使用 eval 函数执行一个字符串表达式都会创建并进入一个新的执行环境，而这个执行环境被称之为**执行上下文**。因此执行上下文有三类：全局执行上下文、函数执行上下文、eval 函数执行上下文.

   执行上下文总共有三种类型：

   - **全局执行上下文**：这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 `this` 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
   - **函数执行上下文：** 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
   - **Eval 函数执行上下文：** 运行在 `eval` 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数。

   执行上下文的生命周期包括三个阶段：**创建阶段 → 执行阶段 → 回收阶段**

   **1. 创建阶段**

   当函数被调用，但未执行任何其内部代码之前，会做以下三件事：

   - 创建变量对象：首先初始化函数的参数` arguments`(形参)，提升函数声明和变量声明。
   - 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
   - 确定 this 指向：包括多种情况，下文会详细说明

   在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。

   另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。

   **2. 执行阶段**

   执行变量赋值、代码执行

   **3. 回收阶段**

   执行上下文出栈等待虚拟机回收执行上下文

   [深入理解 JavaScript 执行上下文和执行栈](https://zhuanlan.zhihu.com/p/59784952)

   [【译】理解 Javascript 执行上下文和执行栈](https://zhuanlan.zhihu.com/p/48590085)

4. ##### 变量对象（VO）是什么？活动对象（AO）是什么？它们有什么联系？

   - **变量对象**是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

   - **活动对象**是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

   未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，AO 还包含函数的 parameters(函数传入的参数)，以及 arguments 这个特殊对象。里面的属性都能被访问了，然后开始进行执行阶段的操作。

   [冴羽大佬的JavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)

5. ##### 作用域链？

   当查找变量的时候，会先从**当前上下文**的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到**全局上下文**的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

   

6. ##### `undefined`和`null`有什么区别？

   赋值角度:

   - `null`表示没有对象，即该处不应该有值.

     - 作为函数的参数，表示该函数的参数不是对象.
     - 作为对象原型链的终点.

   - `undefined`表示缺少值，即此处应该有值，但没有定义.

     - 定义了形参，没有传实参，显示`undefined`.

     - 对象属性名不存在时，显示`undefined`.

     - 函数没有写返回值，即没有写`return`，拿到的是`undefined`.

     - 写了`return`，但是没有赋值，拿到的是`undefined`.

   数据转换角度:

   - `null`默认转成0
   - `undefined`默认转成NaN

7. ##### 对原型、原型链、 Function、Object 的理解.

   **原型**是指把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的` __proto__`存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型。

   **原型链**就是对象通过`__proto__`向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined

   理解下面三句话

   - **当 new 一个函数的时候会创建一个对象，『函数.prototype』 等于 『被创建对象.\_\_proto\_\_』**
   - **函数的原型对象『函数.prototype』都是由 Object 这个函数创建的，所以『Object.prototype === 函数.prototype.\_\_proto\_\_』**
   - **一切函数『函数.prototype.constructor』都是由 Function 这个函数创建的，所以『Function.prototype === 被创建的函数.\_\_proto\_\_』**

   ![原型与原型链](https://raw.githubusercontent.com/xinyiweizhen/ImageGallery/main/blog_img/20210401160225.png)

8. ##### JavaScript中的继承

   常用JavaScript中的继承有7种

   - 原型链继承（**将父类的实例作为子类的原型对象**）
   - 构造函数继承（**子类构造函数中调用父类构造函数**）
   - 组合继承（**用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承**）
   - 原型式继承（**利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型**）
   - 寄生式继承（**在原型式继承的基础上，增强对象，返回构造函数**）
   - 寄生组合继承 （**结合借用构造函数传递参数和寄生模式实现继承**）

   - ES6中的extends继承

   **寄生组合继承**主要实现以下三点

   - 子类构造器中调用父类的构造器，目的是继承父类上的属性
   - 子类构造器的原型指向父类构造器，目的是继承父类的静态方法
   - 子类构造器的原型对象(prototype)的原型(\_\_proto\_\_)指向父类构造器的原型对象，目的是继承父类原型对象的方法

   

   下面有详细的解释

   1. 原型链继承

      **原理：**

      > **将父类的实例作为子类的原型对象**，相当于子类的原型对象的原型指向父类的原型对象

      **实现代码：**

      ```javascript
      function SuperType() {
          this.property = true;
      }
      
      SuperType.prototype.getSuperValue = function() {
          return this.property;
      }
      
      function SubType() {
          this.subproperty = false;
      }
      // 子类构造器的原型对象等于父类的实例
      // 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
      SubType.prototype = new SuperType(); 
      
      SubType.prototype.getSubValue = function() {
          return this.subproperty;
      }
      
      var instance = new SubType();
      console.log(instance.getSuperValue()); // true
      ```

      **原型链图：**

      ![原型链继承](https://user-gold-cdn.xitu.io/2018/10/30/166c2c0107fd80c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

      **优缺点：**

      - 优点：

        > 1. **可以复用父类的方法**

      - 缺点

        > 1. **父类的所有引用属性会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响**
        > 2. **子类型实例不能给父类型构造函数传参**

      

   2. 构造函数继承

      **原理：**

      > 在子类构造函数中调用父类构造函数，可以在子类构造函数中使用`call()`和`apply()`方法，复制父类的实例给子类（不使用原型）

      **实现代码：**

      ```javascript
      function  SuperType(){
          this.color=["red","green","blue"];
      }
      function  SubType(){
          //继承自SuperType
          SuperType.call(this);
      }
      var instance1 = new SubType();
      instance1.color.push("black");
      console.log(instance1.color);// [red,green,blue,black]
      
      var instance2 = new SubType();
      console.log(instance2.color);// [red,green,blue]
      ```

      核心代码是`SuperType.call(this)`，创建子类实例时调用`SuperType`构造函数，于是`SubType`的每个实例都会将`SuperType`中的属性复制一份

      **优缺点：**

      - 优点：

        > 1. **可以在子类构造函数中向父类传参数**
        > 2. **父类的引用属性不会被共享**

      - 缺点

        > 1. **只能继承父类的实例属性和方法，不能继承父类原型属性/方法**
        > 2. **无法实现复用，每个子类都有父类实例函数的副本，影响性能**

      

   3. 组合继承

      **原理**：

      > 组合继承综合了**原型链继承**和盗用**构造函数继承(构造函数继承)**，将两者的优点结合了起来，
      >
      > 基本的思路就是**使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性**

      **实现代码：**

      ```javascript
      function Parent(name) {
         this.name = name
         this.colors = ["red", "blue", "yellow"]
      }
      Parent.prototype.sayName = function () {
         console.log(this.name);
      }
      
      function Child(name, age) {
         // 继承父类属性
         Parent.call(this, name)
         this.age = age;
      }
      // 继承父类方法
      Child.prototype = new Parent();
      
      Child.prototype.sayAge = function () {
         console.log(this.age);
      }
      
      let child1 = new Child("yhd", 19);
      child1.colors.push("pink");
      console.log(child1.colors); // ["red", "blue", "yellow", "pink"]
      child1.sayAge(); // 19
      child1.sayName(); // "yhd"
      
      let child2 = new Child("wxb", 30);
      console.log(child2.colors);  // ["red", "blue", "yellow"]
      child2.sayAge(); // 30
      child2.sayName(); // "wxb"
      ```

      上面例子中，`Parent构造函数`定义了`name，colors`两个属性，接着又在他的原型上添加了个`sayName()`方法。`Child构造函数`内部调用了`Parent构造函数`，同时传入了`name`参数，同时`Child.prototype`也被赋值为`Parent实例`，然后又在他的原型上添加了个`sayAge()`方法。这样就可以创建 `child1，child2两个实例`，让这两个实例都有自己的属性，包括`colors`，同时还共享了父类的`sayName`方法

      **优缺点：**

      - 优点：

        > 1. **父类的方法可以复用**
        > 2. **可以在子类构造函数中向父类构造函数中传参**
        > 3. **父类构造函数中的引用属性不会被共享**

      - 缺点

        > 1. **在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法**

   4. 原型式继承

      **原理：**

      > 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型

      **实现代码：**

      ```javascript
      // object()对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。
      function object(obj){
        function F(){}
        F.prototype = obj;
        return new F();
      }
      
      var person = {
        name: "Nicholas",
        friends: ["Shelby", "Court", "Van"]
      };
      
      var anotherPerson = object(person);
      anotherPerson.name = "Greg";
      anotherPerson.friends.push("Rob");
      
      var yetAnotherPerson = object(person);
      yetAnotherPerson.name = "Linda";
      yetAnotherPerson.friends.push("Barbie");
      
      alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"
      ```

      ES5中存在`Object.create()`的方法只传入一个参数时，能够代替上面的`object`方法

      **优缺点：**

      - 优点：

        > 1. **父类方法可复用**

      - 缺点

        > 1. **原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。**
        > 2. **无法传递参数**

   5. 寄生式继承

      **原理：**

      > 在原型式继承的基础上，增强对象，返回构造函数

      **实现代码：**

      ```javascript
      function object(obj){
        function F(){}
        F.prototype = obj;
        return new F();
      }
      // 函数的主要作用是为构造函数新增属性和方法，以增强函数
      function createAnother(original){
        var clone = object(original); // 通过调用 object() 函数创建一个新对象
        clone.sayHi = function(){  // 以某种方式来增强对象
          alert("hi");
        };
        return clone; // 返回这个对象
      }
      
      let person = {
           name: "yhd",
           friends: ["rose", "tom", "jack"]
      }
      
      let person1 = createAnother(person);
      person1.friends.push("lily");
      console.log(person1.friends);
      person1.getName(); // yhd
      
      let person2 = createAnother(person);
      console.log(person2.friends); // ["rose", "tom", "jack", "lily"]
      
      ```

      **优缺点：**

      - 缺点

        > 1. **原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。**
        > 2. **无法传递参数**

   6. 寄生组合继承

      **原理：**

      > 结合借用构造函数传递参数和寄生模式实现继承

      **实现代码：**

      ```javascript
      function inheritPrototype(subType, superType){
        	// Object.create
          Child.prototype = Object.create(Parent.prototype);  // 指定对象，将新创建的对象赋值给子类的原型
          // __proto__
          // Child.prototype.__proto__ = Parent.prototype; 
          Child.prototype.constructor = Child;   // 增强对象，弥补因重写原型而失去的默认的constructor 属性
          // ES6
          // Object.setPrototypeOf(Child, Parent);
          // __proto__
          Child.__proto__ = Parent; // 子类构造函数的__proto__指向父类构造器，继承父类的静态方法
      }
      
      // 父类初始化实例属性和原型属性
      function SuperType(name){
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }
      SuperType.prototype.sayName = function(){
        alert(this.name);
      };
      
      // 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
      function SubType(name, age){
        SuperType.call(this, name);
        this.age = age;
      }
      
      // 将父类原型指向子类
      inheritPrototype(SubType, SuperType);
      
      // 新增子类原型属性
      SubType.prototype.sayAge = function(){
        alert(this.age);
      }
      
      var instance1 = new SubType("xyc", 23);
      var instance2 = new SubType("lxy", 23);
      
      instance1.colors.push("2"); // ["red", "blue", "green", "2"]
      instance1.colors.push("3"); // ["red", "blue", "green", "3"]
      
      ```

      ![实例的属性](https://user-gold-cdn.xitu.io/2018/10/30/166c2c0109df5438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

      **优缺点：**

      - 优点

        > 1. **只调用一次父类构造函数**
        > 2. **子类可以向父类传参**
        > 3. **父类方法可以复用**
        > 4. **父类的引用属性不会被共享**

   7. ES6的`extends`继承

      `extends`关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中`constructor`表示构造函数，一个类中只能有一个构造函数，有多个会报出`SyntaxError`错误,如果没有显式指定构造方法，则会添加默认的 `constructor`方法，使用例子如下。

      ```javascript
      class Rectangle {
          // constructor
          constructor(height, width) {
              this.height = height;
              this.width = width;
          }
          
          // Getter
          get area() {
              return this.calcArea()
          }
          
          // Method
          calcArea() {
              return this.height * this.width;
          }
      }
      
      const rectangle = new Rectangle(10, 20);
      console.log(rectangle.area);
      // 输出 200
      
      -----------------------------------------------------------------
      // 继承
      class Square extends Rectangle {
      
        constructor(length) {
          super(length, length);
          
          // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
          this.name = 'Square';
        }
      
        get area() {
          return this.height * this.width;
        }
      }
      
      const square = new Square(10);
      console.log(square.area);
      // 输出 100
      
      //复制代码 extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样
      function _inherits(subType, superType) {
        
          // 创建对象，创建父类原型的一个副本
          // 增强对象，弥补因重写原型而失去的默认的constructor 属性
          // 指定对象，将新创建的对象赋值给子类的原型
          subType.prototype = Object.create(superType && superType.prototype, {
              constructor: {
                  value: subType,
                  enumerable: false,
                  writable: true,
                  configurable: true
              }
          });
          
          if (superType) {
              Object.setPrototypeOf 
                  ? Object.setPrototypeOf(subType, superType) 
                  : subType.__proto__ = superType;
          }
      }
      ```

      #### 总结

      1、函数声明和类声明的区别

      函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。

      ```
      let p = new Rectangle(); 
      // ReferenceError
      
      class Rectangle {}
      复制代码
      ```

      2、ES5继承和ES6继承的区别

      - ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.
      - ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。

   [JS继承 原型链继承、构造函数继承、组合继承、原型继承、寄生式继承、寄生组合继承](https://juejin.cn/post/6914216540468576263)

   [JavaScript常用八种继承方案](https://juejin.cn/post/6844903696111763470)

   [面试官问：JS的继承](https://juejin.cn/post/6844903780035592205)

   [《javascript高级程序设计》笔记：继承](https://segmentfault.com/a/1190000011917606)
   [MDN之Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
   [MDN之Class](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)

9. ##### 对`Promise`的理解

   `Promise` 是异步编程的一种方案。从语法上讲，`Promise` 是一个对象，它可以获取异步操作的消息。可以将异步操作以同步的流程表达出来（异步代码同步化）

   **Promise 的基本用法**

   （1）使用new实例化一个`Promise`对象，`Promise`的构造函数中传递一个参数。这个参数是一个函数，该函数用于处理异步任务。

   （2）并且传入两个参数：`resolve`和`reject`，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数；

   （3）通过` promise.then()` 处理返回结果。这里的 p 指的是 `Promise`实例。

   ```javascript
   // 第一步：model层的接口封装
               const promise = new Promise((resolve, reject) => {
                   // 这里做异步任务（比如ajax 请求接口。这里暂时用定时器代替）
                   setTimeout(function() {
                       var data = { retCode: 0, msg: 'ok' }; // 接口返回的数据
                       if (data.retCode == 0) {
                           // 接口请求成功时调用
                           resolve(data);
                       } else {
                           // 接口请求失败时调用
                           reject({ retCode: -1, msg: 'network error' });
                       }
                   }, 100);
               });
   
               // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据
               promise.then(data => {
                   // 从 resolve 获取正常结果
                   console.log(data);
               }).catch(data => {
                   // 从 reject 获取异常结果
                   console.log(data);
               });
   ```

   **promise对象的3个状态（了解即可）**

   - 初始化状态（等待状态）：`pending`
   - 成功状态：`fullfilled`
   - 失败状态：`rejected`

   **Promise 的常用API：实例方法【重要】**

   Promise 自带的API提供了如下实例方法：

   - promise.then()：获取异步任务的正常结果。
   - promise.catch()：获取异步任务的异常结果。
   - promise.finaly()：异步任务无论成功与否，都会执行。

   **Promise 的常用API：对象方法【重要】**

   - Promise.all()：并发处理多个异步任务，所有任务都执行成功，才能得到结果。
   - Promise.race(): 并发处理多个异步任务，只要有一个任务执行成功，就能得到结果。

10. ##### Promise.all、Promise.race 分别怎么用 ?

   [`Promise.all(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)

   该方法返回一个`Promise`实例，此实例在 `iterable` 参数内所有的`promise` 都“完成（resolved）”或参数中不包含`promise`时回调完成（resolve）；如果参数中 `promise`有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败`promise`的结果。

   ```javascript
   var p1 = new Promise((resolve, reject) => {
     setTimeout(resolve, 1000, 'one');
   });
   var p2 = new Promise((resolve, reject) => {
     setTimeout(resolve, 2000, 'two');
   });
   var p3 = new Promise((resolve, reject) => {
     setTimeout(resolve, 3000, 'three');
   });
   var p4 = new Promise((resolve, reject) => {
     setTimeout(resolve, 4000, 'four');
   });
   var p5 = new Promise((resolve, reject) => {
     reject('reject');
   });
   
   Promise.all([p1, p2, p3, p4]).then(values => {
     console.log(values);
   }, reason => {
     console.log(reason)
   });
   //From console:
   //["one", "two", "three", "four"]
   
   Promise.all([p1, p2, p3, p4, p5]).then(values => {
     console.log(values);
   }, reason => {
     console.log(reason)
   });
   
   //From console:
   //"reject"
   
   //You can also use .catch
   Promise.all([p1, p2, p3, p4, p5]).then(values => {
     console.log(values);
   }).catch(reason => {
     console.log(reason)
   });
   
   //From console:
   //"reject"
   ```

   [`Promise.race(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)

   方法返回一个 `Promise`实例对象，一旦迭代器中的某个`promise`解决（resolved）或拒绝（rejected），返回的 `promise`就会解决或拒绝。

   ```javascript
   var p1 = new Promise(function(resolve, reject) {
       setTimeout(resolve, 500, "one");
   });
   var p2 = new Promise(function(resolve, reject) {
       setTimeout(resolve, 100, "two");
   });
   
   Promise.race([p1, p2]).then(function(value) {
     console.log(value); // "two"
     // 两个都完成，但 p2 更快
   });
   
   var p3 = new Promise(function(resolve, reject) {
       setTimeout(resolve, 100, "three");
   });
   var p4 = new Promise(function(resolve, reject) {
       setTimeout(reject, 500, "four");
   });
   
   Promise.race([p3, p4]).then(function(value) {
     console.log(value); // "three"
     // p3 更快，所以它完成了
   }, function(reason) {
     // 未被调用
   });
   
   var p5 = new Promise(function(resolve, reject) {
       setTimeout(resolve, 500, "five");
   });
   var p6 = new Promise(function(resolve, reject) {
       setTimeout(reject, 100, "six");
   });
   
   Promise.race([p5, p6]).then(function(value) {
     // 未被调用
   }, function(reason) {
     console.log(reason); // "six"
     // p6 更快，所以它失败了
   });
   ```

   

   [MDN-Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)

   [必考：Promise、Promise.all、Promise.race 分别怎么用？](https://zhuanlan.zhihu.com/p/112574291)

11. ##### 聊一聊DOM事件流、事件冒泡、事件捕获、事件委托？

    DOM事件流包括三个阶段。

    简而言之：事件一开始从文档的根节点流向目标对象（**捕获阶段**），然后在目标对象上被触发（**目标阶段**），之后再回溯到文档的根节点（**冒泡阶段**）。

    - **事件捕获阶段（Capture Phase）** DOM事件流的第一个阶段是捕获阶段。事件从文档的根节点出发，随着 DOM 树的结构向事件的目标节点流去。途中经过各个层次的 DOM 节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。

    - **目标阶段（Target Phase）** 当事件到达目标节点，事件就进入了目标阶段。事件在目标节点上被触发(执行事件对应的函数)，然后会逆向回流，直到传播至最外层的文档节点。

    - **冒泡阶段（Bubble Phase）**事件在目标元素上触发后，并不在这个元素上终止。它会随着 DOM 树一层层向上冒泡，直到到达最外层的根节点。也就是说，同一个事件会依次在目标节点的父节点，父节点的父节点.....一直到最外层的节点上被触发。

      

      ![javascript事件流](https://raw.githubusercontent.com/xinyiweizhen/ImageGallery/main/blog_img/20210407114909.jpg)

      > 注：所有的事件都要经过捕捉阶段和目标阶段，但是有些事件会跳过冒泡阶段。例如，让元素获得输入焦点的 `focus` 事件以及失去输入焦点的 `blur `事件就都不会冒泡。

      

    **事件对象**    👉[event:MDN传送门](https://developer.mozilla.org/zh-CN/docs/Web/API/Event)

    在触发DOM上的某个事件时，会产生一个事件对象`event`，该对象包含所有与事件有关的信息。所有的浏览器都支持 event 对象，但支持方式不同。

    `event`常用的一些属性和方法：

    1. `target`   事件的目标
    2. `type`    被触发的事件类型
    3. `currentTarget`   绑定事件的元素，与 `this`的指向相同
    4. `eventPhase`  表示事件流当前处于哪一个阶段。
       - `Event.NONE` === 0 表示这个时间没有事件正在被处理，
       - `Event.CAPTURING_PHASE` === 1表示捕获阶段，
       - `Event.AT_TARGET` === 2表示“处于目标”，
       - `Event.BUBBLING_PHASE` === 3表示冒泡阶段
    5.  `stopPropagation()`    取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法
    6. `preventDefault()`   取消事件的默认行为，比如点击链接跳转。如果 `cancelable` 是 `true`，则可以使用这个方法

    

    **事件委托**

    事件委托是为了解决事件处理程序过多造成的内存和性能问题。那么什么是事件委托呢？

    就是利用事件冒泡,只指定一个事件处理程序，就可以管理某一类型的所有事件。同一个DOM元素注册多个同类型事件。

    ```html
    <ul id="list">
        <li>red</li>
        <li>yellow</li>
        <li>blue</li>
    </ul>
    <script>
    	var list = document.getElementById('list');
        list.addEventListener('click',showColor,false);
        function showColor(e){
            var x = e.target;
            if(x.nodeName.toLowerCase() === 'li'){
                alert('The color is ' + x.innerHTML);
            }
        }
    </script>
    ```

    > ##### 事件委托的优点
    >
    > ​	可以大量节省内存的占用，减少事件注册
    >
    > ​	可以实现新增的子对象时无需再次绑定事件
    >
    > ##### 使用事件委托注意事项
    >
    > ​	使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。
    >
    > ​	事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。
    >
    > ​	如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。

    参考：

    ​	[彻底弄懂JS事件委托的概念和作用](https://www.cnblogs.com/soyxiaobi/p/9498357.html)

    ​	[javascript 事件流和事件委托](https://juejin.cn/post/6854573221983813645)

    ​	[搞懂js事件、事件流(捕获冒泡)、事件委托](https://zhuanlan.zhihu.com/p/321432610)

12. ##### 说下事件循环(Event Loop)

    1. 事件循环的理解

        因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。

    2. 单线程

        为什么javascript不设计成多线程的? 我们做个假设，如果javascript是多线程的，因为javascript有DOM API可以操作DOM，此时如果有两个线程在操作同一个DOM，线程1删除了这个DOM节点，线程2要操作这个DOM，就会产生矛盾，到底以哪个线程为主。

        为了避免这种情况的出现，javascript就被设计成了单线程 。

    3. 宏任务和微任务

        宏任务有：

        - `script`整体代码
        - `setTimeout`、`setInterval`
        - I/O
        - UI渲染
        - `postMessage`
        - `MessageChannel`
        - `requestAnimationFrame`
        - `setImmediate`(Node 环境)

        微任务有：

        - `new Promise.then()`
        - `MutaionObserver`(监视对DOM树所做更改的能力)
        - `process.nextTick`(Node 环境)

    4. 执行规则

        Event Loop的执行规则：

        - 所有代码作为宏任务进入主线程执行栈，开始执行
        - 执行过程中，同步代码会立即执行，宏任务进入宏任务队列，微任务进入微任务队列
        - 当前宏任务执行完成出队，读取微任务队列，有则执行，直至全部执行完毕
        - 执行浏览器UI进程渲染
        - 检查是否有web worker任务，有则执行
        - 本轮宏任务执行完成，回到第2步，继续执行，直至宏任务与微任务队列全部清空

    5. 代码例子

        ```javascript
        console.log("1"); // 1 同步代码：立即执行 [1]
        
        setTimeout(function() {
          console.log("2"); // 3 同步代码执行执行 输出2
          process.nextTick(function() {
            console.log("3"); // 4 进入微任务队列 [3]
          });
          new Promise(function(resolve) {
            console.log("4"); // 3 同步代码执行执行 输出4
            resolve();
          }).then(function() {
            console.log("5"); // 4 进入微任务队列 [3, 5]
          });
        });
        
        process.nextTick(function() {
          console.log("6"); // 2 进入微任务队列 [6]
        });
        
        new Promise(function(resolve) {
          console.log("7"); // 1 宏任务：立即执行 [1, 7]
          resolve();
        }).then(function() {
          console.log("8"); // 2 进入微任务队列 [6, 8]
        });
        
        setTimeout(function() {
          console.log("9"); // 5 宏任务：立即执行 [9]
          process.nextTick(function() {
            console.log("10"); // 6 进入微任务队列 [10]
          });
          new Promise(function(resolve) {
            console.log("11"); // 5 宏任务：立即执行 [9, 11]
            resolve();
          }).then(function() {
            console.log("12"); // 6 进入微任务队列 [10, 12]
          });
        });
        
        // 执行顺序：1 7 6 8 2 4 3 5 9 11 10 12
        ```

        我们来分析下上述代码的执行顺序，如下图所示：

        ![执行顺序](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79eda5cc57334da4807a3f41d53debb8~tplv-k3u1fbpfcp-watermark.image)
        
        [如何解释Event Loop面试官才满意？](https://zhuanlan.zhihu.com/p/72507900)
        
        

13. ##### 闭包的概念？闭包的场景？

    **简单讲**：

    **闭包** 指的是**有权访问引用了另一个函数作用域中变量的函数**。  

    **概念：**

    MDN 对闭包的定义为：

    > 闭包是指那些能够访问自由变量的函数。

    那什么是自由变量呢？

    > 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

    由此，我们可以看出闭包共有两部分组成：

    > 闭包 = 函数 + 函数能够访问的自由变量

    ECMAScript中，闭包指的是：

    1. 从理论角度：即使外部上下文已经被销毁，但依旧能访问到已销毁上下文中的变量的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
    2. 从实践角度：以下函数才算是闭包：
       1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
       2. 在代码中引用了自由变量

    **实践理解闭包：**

    ```javascript
    var scope = "global scope";
    function checkscope(){
        var scope = "local scope";
        function f(){
            return scope;
        }
        return f;
    }
    
    var foo = checkscope();
    foo();
    ```

    这段代码的上下文变化如下：

    1. 进入全局代码，创建全局执行上下文，将全局执行上下文压入栈中。
    2. 初始化执行全局上下文。创建全局对象，确定作用域链，以及this指向。
    3. 初始化全局上下文的同时，函数`checkscope`被创建，将父级作用域链保存至内部属性[[scope]]
    4. `checkscope`被执行，创建`checkscope`函数执行上下文，压入栈中。
    5. 初始化`checkscope`函数执行上下文。
       1. 复制[[scope]]属性，创建作用域链。
       2. 用arguments创建活动对象。
       3. 初始化活动对象，即加入形参，var声明的变量，函数声明。
       4. 将活动对象压入作用域顶端，确定完整的作用域链。
       5. 确定this指向。
    6. 初始化`checkscope`函数的同时，f函数被创建，保存父级作用域链至内部属性[[scope]]。
    7. `checkscope`函数代码执行完毕，返回f函数，出栈。
    8. `foo`函数执行（引用同f函数一致）。创建`foo`函数执行上下文，压入栈中。
    9. `foo`函数执行上下文初始化。
       1. 复制[[scope]]属性，创建作用域链。
       2. 用arguments创建活动对象。
       3. 初始化活动对象，即加入形参，var声明的变量，函数声明。
       4. 将活动对象压入作用域顶端，确定完整的作用域链。
       5. 确定this指向。

    10.`foo`函数代码执行完毕，返回scope属性，出栈。

    **使用场景：**

    - setTimeout传参

    - 封装私有变量、模块化

    - 缓存

      还有很多用途说出一两个了解过的就行。

    [JavaScript深入之闭包](https://github.com/mqyqingfeng/Blog/issues/9)

    [javaScript-闭包](https://github.com/pengyw97/Blog/issues/7)

    [面试 | JS 闭包经典使用场景和必刷题](https://github.com/lurenacm/againJS/issues/2)

    [每日一题」JS 中的闭包是什么？](https://zhuanlan.zhihu.com/p/22486908)

14. ##### ES6的新特性

    - let/const（常用） 面试会涉及到var、let、const的区别
    - 箭头函数（常用）面试会涉及到箭头函数与普通函数的区别
    - 解构赋值（常用）面试会涉及对象的结构和数组的结构
    - 剩余/扩展运算符（常用）
    - 对象属性/方法简写（常用）
    - 字符串新增的方法（常用）
    - Promise对象（常用）
    - 类的定义与类的继承（常用）
    - for ... of循环
    - ES6 Module(常用)
    - 函数默认值(常用)
    - Proxy
    - iterator迭代器
    - map，filter，reduce
    - ......

    [面试题之ES6的新特性（详细）](https://zhuanlan.zhihu.com/p/235025429)

    [ES6中常用的10个新特性讲解](https://juejin.cn/post/6844903618810757128)

    [hello-es6](https://github.com/xinyiweizhen/hello-es6)

    [ECMAScript 6 入门](https://es6.ruanyifeng.com/)
    
15. ##### JavaScript数组所有API全解密

    **改变自身值的方法(9个)**

    基于ES6，改变自身值的方法一共有9个，分别为`pop`、`push`、`reverse`、`shift`、`sort`、`splice`、`unshift`，以及两个ES6新增的方法`copyWithin` 和 `fill`。

    **不会改变自身的方法(9个)**

    基于ES7，不会改变自身的方法一共有9个，分别为`concat`、`join`、`slice`、`toString`、`toLocateString`、`indexOf`、`lastIndexOf`、未标准的`toSource`以及ES7新增的方法`includes`。

    **遍历方法(12个)**

    基于ES6，不会改变自身的方法一共有12个，分别为`forEach`、`every`、`some`、`filter`、`map`、`reduce`、`reduceRight` 以及ES6新增的方法`entries`、`find`、`findIndex`、`keys`、`values`。

    [【深度长文】JavaScript数组所有API全解密](http://louiszhai.github.io/2017/04/28/array/)

16. ##### JavaScript字符串所有API全解密

    [JavaScript字符串所有API全解密](http://louiszhai.github.io/2016/01/12/js.String/)

17. ##### JavaScript中二进制数组、Blob、

    - ArrayBuffer对象

      **概念：**

      `ArrayBuffer`对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（`TypedArray`视图和`DataView`视图)来读写，视图的作用是以指定格式解读二进制数据。`ArrayBuffer`也是一个构造函数。

      ```javascript
      // 生成了一段32字节的内存区域，每个字节的值默认都是 0 。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。
      var buffer = new ArrayBuffer(32);
      
      
      // ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。   
      // ArrayBuffer.prototype.byteLength
      buffer.byteLength // 32
      
      
      // ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。  
      // ArrayBuffer.prototype.slice()
      var newBuffer = buffer.slice(0, 3);
      
      // 注意：
      // 除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。
      ```

    - TypedArray对象(视图)

      **概念：**

      `ArrayBuffer`对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。`ArrayBuffer`有两种视图，一种是`TypedArray`视图，另一种是`DataView`视图，两者的区别主要是字节序，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。

      目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。

      > - **Int8Array**：8位有符号整数，长度1个字节。
      > - **Uint8Array**：8位无符号整数，长度1个字节。
      > - **Uint8ClampedArray**：8位无符号整数，长度1个字节，溢出处理不同。
      > - **Int16Array**：16位有符号整数，长度2个字节。
      > - **Uint16Array**：16位无符号整数，长度2个字节。
      > - **Int32Array**：32位有符号整数，长度4个字节。
      > - **Uint32Array**：32位无符号整数，长度4个字节。
      > - **Float32Array**：32位浮点数，长度4个字节。
      > - **Float64Array**：64位浮点数，长度8个字节。

    - DataView视图

    

    看完能轻松看懂转换关系图：

    ![转换关系图](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca00cdc946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    

    [二进制数组](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc0)

    [MDN - ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)

    [MDN - TypedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)

    [MDN - DataView](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView)

    [MDN - Uint8Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)

    [聊聊JS的二进制家族：Blob、ArrayBuffer和Buffer](https://zhuanlan.zhihu.com/p/97768916)

    [ 玩转前端二进制](https://juejin.cn/post/6846687590783909902)

### 手写题或者代码题

1. ##### 能否模拟实现javascript的`new`操作符

   **`new`做了什么：**

   - 创建了一个全新的对象。

   - 这个对象会被执行`[[Prototype]]`（也就是`__proto__`）链接。

   - 生成的新对象会绑定到函数调用的`this`。

   - 通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。

   - 如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。

   **如何实现：**

   ```javascript
   /**
    * 模拟实现 new 操作符
    * @param  {Function} ctor [构造函数]
    * @return {Object|Function|Regex|Date|Error}      [返回结果]
    */
   function newOperator(ctor){
       if(typeof ctor !== 'function'){
         throw 'newOperator function the first param must be a function';
       }
       // ES6 new.target 是指向构造函数
       newOperator.target = ctor;
       // 1.创建一个全新的对象，
       // 2.并且执行[[Prototype]]链接
       // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
       var newObj = Object.create(ctor.prototype);
       // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);
       // 除去ctor构造函数的其余参数
       var argsArr = Array.prototype.slice.call(arguments, 1);
       // 3.生成的新对象会绑定到函数调用的`this`。
       // 获取到ctor函数返回结果
       var ctorReturnResult = ctor.apply(newObj, argsArr);
       // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null
       var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;
       var isFunction = typeof ctorReturnResult === 'function';
       if(isObject || isFunction){
           return ctorReturnResult;
       }
       // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。
       return newObj;
   }
   ```

   [面试官问：能否模拟实现JS的new操作符](https://juejin.cn/post/6844903704663949325)

   [JavaScript深入之new的模拟实现](https://github.com/mqyqingfeng/Blog/issues/13)

2. ##### 能否模拟实现javascript的`bind`方法

   **`bind`做了什么：**

   - `bind`是`Function`原型链中的`Function.prototype`的一个属性，它是一个函数，修改`this`指向，合并参数传递给原函数，返回值是一个新的函数。
   - `bind`返回的函数可以通过`new`调用，这时提供的`this`的参数被忽略，指向了`new`生成的全新对象。内部模拟实现了`new`操作符。

   **如何实现：**

   ```javascript
   Function.prototype.bindFn = function bind(thisArg){
       if(typeof this !== 'function'){
           throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
       }
       // 存储调用bind的函数本身
       var self = this;
       // 去除thisArg的其他参数 转成数组
       var args = Array.prototype.slice.call(arguments, 1);
       var bound = function(){
           // bind返回的函数 的参数转成数组
           var boundArgs = Array.prototype.slice.call(arguments);
           var finalArgs = args.concat(boundArgs);
           // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。
           if(this instanceof bound){
               // 这里是实现上文描述的 new 的第 1, 2, 4 步
               // 1.创建一个全新的对象
               // 2.并且执行[[Prototype]]链接
               // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
               // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。
               if(self.prototype){
                   // ES5 提供的方案 Object.create()
                   // bound.prototype = Object.create(self.prototype);
                   // 但 既然是模拟ES5的bind，那浏览器也基本没有实现Object.create()
                   // 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create
                   function Empty(){}
                   Empty.prototype = self.prototype;
                   bound.prototype = new Empty();
               }
               // 这里是实现上文描述的 new 的第 3 步
               // 3.生成的新对象会绑定到函数调用的`this`。
               var result = self.apply(this, finalArgs);
               // 这里是实现上文描述的 new 的第 5 步
               // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，
               // 那么`new`表达式中的函数调用会自动返回这个新的对象。
               var isObject = typeof result === 'object' && result !== null;
               var isFunction = typeof result === 'function';
               if(isObject || isFunction){
                   return result;
               }
               return this;
           }
           else{
               // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果
               return self.apply(thisArg, finalArgs);
           }
       };
       return bound;
   }
   ```

   [面试官问：能否模拟实现JS的bind方法](https://zhuanlan.zhihu.com/p/50539121)

   [JavaScript深入之bind的模拟实现](https://github.com/mqyqingfeng/Blog/issues/12)

3. ##### 实现JavaScript数组原型的方法

   - **forEach**

     ```javascript
     Array.prototype.forEach1 = function (callback, thisArg) {
         if(this === null){
             throw new TypeError('this is null or not defined');
         }
         if(typeof callback !== 'function'){
             throw new TypeError(callback + ' is not a function');
         }
         // 生成数组
         const arr = Object(this);
     	// 无符号右移，保证length为整数
         const len = arr.length >>> 0;
         let k = 0;
         while ( k <len){
             if(k in arr){
                 callback.call(thisArg, arr[k], k, arr);
             }
             k++;
         }
     
     }
     ```
   
     [something >>> 0 是什么意思](https://zhuanlan.zhihu.com/p/100790268)
   
     [forEach#polyfill实现](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#polyfill)
   
   - **map**
   
     ```javascript
     ```
   
     
   
4. ##### 手写二分查找(应届生常考)

   二分查找法的思路就是通过条件判断每次淘汰掉一半的数据，从而可以达到一个非常快的查找速度。

   ```javascript
   /**
    * 二分查找（非递归）
    * @param list  一个有序的数组
    * @param target 目标
    * @returns {null|*}
    */
   function binarySearch(list, target){
       let start = 0, end = list.length - 1
       // 重点: 因为闭区间 [start, end]，所以到了begin等于end时，其实区间内还有一个值要判断，因此只有begin>end的时候才能停止
       while (start <= end){
           // js中无符号右移保证为整数
           let mid = ((start + end) / 2) >>> 1
           if(list[mid] === target){
               return list[mid]
           }else if(list[mid] > target){
               // 搜索范围变为[left, mid - 1]
               end = mid - 1
           }else {
               // 搜索范围变成[mid + 1, end]
               start = mid + 1
           }
       }
       return null
   }
   
   /**
    * 二分查找（递归版本）
    * @param list
    * @param target
    * @returns {number}
    */
   function binarySearch(list, target){
       function search(list, start, end, target){
           if(start > end) return -1
           let mid = ((start + end) / 2) >>> 1
           if(list[mid] === target){
               return list[mid]
           } else if(list[mid] > target){
               return search(list, start, mid - 1, target)
           }else {
               return search(list, mid + 1, end, target)
           }
       }
       return search(list, 0, list.length -1, target)
   }
   ```

   

### React

1. ##### `setState`更新的原理？可以手动实现`setState`吗？

   参考: 

   ​	[react setState核心实现原理](https://zhuanlan.zhihu.com/p/44537887)

   ​	[React setState 调用的原理](https://juejin.cn/post/6941546135827775525#heading-30)
   
   ​	[Dan Abramov - setState如何知道该做什么？](https://overreacted.io/zh-hans/how-does-setstate-know-what-to-do/)
   
2. ##### 生命周期详细描述一下？官方为什么改变？

   **`v15`生命周期：**

   ![`v15`生命周期](https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x1vQXZlzRCJSw0RXvoOUfEfcmdXQ04lSWgXMZfaFzkYMQzmiaWaOSwtibMUtkceUiaNtMJWRPPe353WQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   - 初始化阶段

   - - `constructor` 构造函数
     - `getDefaultProps` `props`默认值
     - `getInitialState` `state`默认值

   - 挂载阶段

   - - `componentWillMount` 组件初始化渲染前调用
     - `render` 组件渲染
     - `componentDidMount`组件挂载到 `DOM`后调用

   - 更新阶段

   - - `componentWillReceiveProps` 组件将要接收新 `props`前调用
     - `shouldComponentUpdate` 组件是否需要更新
     - `componentWillUpdate` 组件更新前调用
     - `render` 组件渲染
     - `componentDidUpdate` 组件更新后调用

   - 卸载阶段

   - - `componentWillUnmount` 组件卸载前调用

   **`v16`生命周期:**

   ![`v16`生命周期](https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x1vQXZlzRCJSw0RXvoOUfEf5vy0iacInDoDic8iatb1cdBSOeiaJtwjAJMNxxvxteicTWxibouJdmIKicjEQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   - 初始化阶段

   - - `constructor` 构造函数
     - `getDefaultProps` `props`默认值
     - `getInitialState` `state`默认值

   - 挂载阶段

   - - `staticgetDerivedStateFromProps(props,state)`
     - `render`
     - `componentDidMount`

   - > `getDerivedStateFromProps`：组件每次被 `rerender`的时候，包括在组件构建之后(虚拟 `dom`之后，实际 `dom`挂载之前)，每次获取新的 `props`或 `state`之后；每次接收新的props之后都会返回一个对象作为新的 `state`，返回null则说明不需要更新 `state`；配合 `componentDidUpdate`，可以覆盖 `componentWillReceiveProps`的所有用法

   - 更新阶段

   - - `staticgetDerivedStateFromProps(props,state)`
     - `shouldComponentUpdate`
     - `render`
     - `getSnapshotBeforeUpdate(prevProps,prevState)`
     - `componentDidUpdate`

   - > `getSnapshotBeforeUpdate`：触发时间: `update`发生的时候，在 `render`之后，在组件 `dom`渲染之前；返回一个值，作为 `componentDidUpdate`的第三个参数；配合 `componentDidUpdate`, 可以覆盖 `componentWillUpdate`的所有用法

   - 卸载阶段

   - - `componentWillUnmount`

   - 错误处理

   - - `componentDidCatch`

   `React16`新的生命周期弃用了 `componentWillMount`、`componentWillReceivePorps`, `componentWillUpdate`新增了 `getDerivedStateFromProps`、`getSnapshotBeforeUpdate`来代替弃用的三个钩子函数。

   > `React16`并没有删除这三个钩子函数，只是认为是不安全的，但是不能和新增的钩子函数混用， `React17`将会删除这三个钩子函数，新增了对错误的处理（ `componentDidCatch`）

   **废弃的原因：**

   ​	因为协调阶段可能被中断、恢复，甚至重做，**⚠️React 协调阶段的生命周期钩子可能会被调用多次!**，例如 `componentWillMount` 可能会被调用两次。

   ​	

   ​	因此建议 **协调阶段的生命周期钩子不要包含副作用**。索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如`componentWillMount`、`componentWillUpdate`。` v17`后我们就不能再用它们了，所以现有的应用应该尽快迁移。

   [React 生命周期图](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

   [官方生命周期方法](https://zh-hans.reactjs.org/docs/react-component.html)

   [React高频面试题梳理，看看面试怎么答？（上）](https://mp.weixin.qq.com/s/W7CNGn-Qc8o0EQ3bIKAJBQ)

   [这可能是最通俗的 React Fiber(时间分片) 打开方式](https://juejin.cn/post/6844903975112671239)
   
3. ##### React 16中新生命周期有哪些? 新的解读

   关于 React16 开始应用的新生命周期：

   ![ React16 生命周期](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2f59925a79e470eb730e605854e81b8~tplv-k3u1fbpfcp-zoom-1.image)

   可以看出，React16 自上而下地对生命周期做了另一种维度的解读：

   - **Render 阶段**：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的；

   - **Pre-commit阶段**：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；

   - **Commit 阶段**：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。

   与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：

   - 挂载过程：
     - [**constructor**](https://zh-hans.reactjs.org/docs/react-component.html#constructor)
     - [**getDerivedStateFromProps**](https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)
     - [**render**](https://zh-hans.reactjs.org/docs/react-component.html#render)
     - [**componentDidMount**](https://zh-hans.reactjs.org/docs/react-component.html#componentdidmount)
   - 更新过程：
     - [**getDerivedStateFromProps**](https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)
     - [**shouldComponentUpdate**](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)
     - [**render**](https://zh-hans.reactjs.org/docs/react-component.html#render)
     - [**getSnapshotBeforeUpdate**](https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate)
     - [**componentDidUpdate**](https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate)
   - 卸载过程：
     - [**componentWillUnmount**](https://zh-hans.reactjs.org/docs/react-component.html#componentwillunmount)

   [React 16中新生命周期有哪些](https://juejin.cn/post/6941546135827775525#heading-60)
   
4. ##### 什么是 React Context ?

   `Context`  提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。

   [Context](https://zh-hans.reactjs.org/docs/context.html)

5. **React Diff 原理**

   **diff 策略:**

   1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
   2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
   3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

   基于以上三个前提策略，`React` 分别对` tree diff`、`component diff` 以及 `element diff` 进行算法优化。

   - `tree diff`

     基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

     ![tree diff](https://pic1.zhimg.com/80/0c08dbb6b1e0745780de4d208ad51d34_720w.png)

     React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

     如果出现了 DOM 节点跨层级的移动操作,如下图：

     ![DOM 节点跨层级的移动操作](https://pic2.zhimg.com/80/d712a73769688afe1ef1a055391d99ed_720w.png)

     A 节点（包括其子节点）整个被移动到 D 节点下，**由于 React 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作**。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：**create A -> create B -> create C -> delete A**。

     由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 **React 官方建议不要进行 DOM 节点跨层级的操作**。

     > 注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。

   - `component diff`

     React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。

     - 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。

     - 如果不是，则将该组件判断为 dirty component，从而**替换**整个组件下的所有子节点。

     - 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 `shouldComponentUpdate() `来判断该组件是否需要进行 diff。

       ![component diff](https://pic1.zhimg.com/80/52654992aba15fc90e2dac8b2387d0c4_720w.png)

       如上图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。

   - `element diff`

     当节点处于同一层级时，React diff 提供了三种节点操作，分别为：**INSERT_MARKUP**（插入）、**MOVE_EXISTING**（移动）和 **REMOVE_NODE**（删除）。

     - **INSERT_MARKUP**，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。

     - **MOVE_EXISTING**，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。

     - **REMOVE_NODE**，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。

       [例子](https://zhuanlan.zhihu.com/p/20346379)

   **总结**

   - React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；
   - React 通过**分层求异**的策略，对 tree diff 进行算法优化；
   - React 通过**相同类生成相似树形结构，不同类生成不同树形结构**的策略，对 component diff 进行算法优化；
   - React 通过**设置唯一 key**的策略，对 element diff 进行算法优化；
   - 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；
   - 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

   [React 源码剖析系列 － 不可思议的 react diff](https://zhuanlan.zhihu.com/p/20346379)

6. ##### React diff 算法的原理是什么？

   实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。 

   ![CgqCHl_qyouAAkb9AAB_cmWuZhc920_mh1609406106571.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44d4ebb48a74ffda63754428c9d5273~tplv-k3u1fbpfcp-zoom-1.image) 具体的流程如下：

   - 真实的 DOM 首先会映射为虚拟 DOM；
   - 当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；
   - 根据 patch 去更新真实的 DOM，反馈到用户的界面上。

   ![CgqCHl_qypGAZPuGAADYrK9nkJY878_mh1609406162857.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246e03a02e3e48ff941f921843bd8676~tplv-k3u1fbpfcp-zoom-1.image) 一个简单的例子：

   ```javascript
   import React from 'react'
   export default class ExampleComponent extends React.Component {
     render() {
       if(this.props.isVisible) {
          return <div className="visible">visbile</div>;
       }
        return <div className="hidden">hidden</div>;
     }
   }
   ```

   这里，首先假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。

   ```javascript
   <div class="visible">visbile</div>
   ```

   当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。**这样一个生成补丁、更新差异的过程统称为 diff 算法。**

   diff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：

   **策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）**

   这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。

   **策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）**

   在组件比对的过程中：

   - 如果组件是同一类型则进行树比对；
   - 如果不是则直接放入补丁中。

   只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。

   **策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）**

   元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。

   [React diff 算法的原理](https://juejin.cn/post/6940942549305524238#heading-25)
   
7. ##### React的性能优化

   

### Vue

1. ##### v-show与v-if区别是什么

   **手段**：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；

   **编译过程**：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；

   **编译条件**：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；

   **性能消耗**：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

   **使用场景**：v-if适合运营条件不大可能改变；v-show适合频繁切换。

   ![v-show与v-if区别](https://img2018.cnblogs.com/blog/1650307/201908/1650307-20190819162826144-758116745.png)

   [2021」高频前端面试题汇总之Vue篇 （上） —— v-show与v-if区别](https://juejin.cn/post/6919373017218809864#heading-19)

2. ##### watch、computed、methods区别是什么

   **对于Computed：**

   - 它支持缓存，只有依赖的数据发生了变化，才会重新计算
   - 不支持异步，当Computed中有异步操作时，无法监听数据的变化
   - computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。
   - 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
   - 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。

   **对于Watch：**

   - 它不支持缓存，数据变化时，它就会触发相应的操作
   - 支持异步监听
   - 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
   - 当一个属性发生变化时，就需要执行相应的操作
   - 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：
     - immediate：组件加载立即触发回调函数
     - deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。

   当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。

   **总结：**

   - computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。
   - watch 侦听器 : 更多的是**观察**的作用，**无缓存性**，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。

   **运用场景：**

   - 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。
   - 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

   **Computed 和 Methods 的区别**

   可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的

   **不同点：**

   - computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；
   - method 调用总会执行该函数。

   []()

### webpack

1. ##### `webpack`的打包流程

   构建过程核心完成了 **内容转换 + 资源合并** 两种功能，实现上包含三个阶段：

   1. 初始化阶段：

   2. 1. **初始化参数**：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数
      2. **创建编译器对象**：用上一步得到的参数创建 `Compiler` 对象
      3. **初始化编译环境**：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等
      4. **开始编译**：执行 `compiler` 对象的 `run` 方法
      5. **确定入口**：根据配置中的 `entry` 找出所有的入口文件，调用 `compilition.addEntry` 将入口文件转换为 `dependence` 对象

   3. 构建阶段：

   4. 1. **编译模块(make)**：根据 `entry` 对应的 `dependence` 创建 `module` 对象，调用 `loader` 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理
      2. **完成模块编译**：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 **依赖关系图**

   5. 生成阶段：

   6. 1. **输出资源(seal)**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
      2. **写入文件系统(emitAssets)**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

   在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

   

   [[万字总结] 一文吃透 Webpack 核心原理](https://zhuanlan.zhihu.com/p/363928061)
   
   [[建议收藏] Webpack 4+ 优秀学习资料合集](https://zhuanlan.zhihu.com/p/372721645)
   
2. ##### 关于babel

   Babel 是 JavaScript 的编译器. Babel 就是一套解决方案，用来把 ES6 的代码转化为浏览器或者其它环境支持的代码。**注意我的用词哈，我说的不是转化为 ES5 ，因为不同类型以及不同版本的浏览器对 ES6 新特性的支持程度都不一样，对于浏览器已经支持的部分，Babel 可以不转化，所以 Babel 会依赖浏览器的版本，后面会讲到。 这里可以先参考 [browerslist](https://link.zhihu.com/?target=https%3A//twitter.com/browserslist) 项目。**
   
   
   
   **babel组成**
   
   ![img](https://pic3.zhimg.com/80/v2-29d8d4701f6df08ccafc853af268b5a2_720w.jpg)
   
   [关于babel](https://bbs.huaweicloud.com/blogs/100006)
   
   [babel 7：不仅是会用](https://zhuanlan.zhihu.com/p/131566326)
   
   [前端科普系列-Babel：把 ES6 送上天的通天塔](https://zhuanlan.zhihu.com/p/129089156)
   
3. ##### postcss相关

   [CSS 工程化](https://xie.infoq.cn/article/ea544e38c14f7b4cfc6c41571)

### 网络

1. ##### 谈一谈你对 TCP/IP 四层模型，OSI 七层模型的理解？

   为了增强通用性和兼容性，计算机网络都被设计成层次机构，每一层都遵守一定的规则。

   因此有了OSI这样一个抽象的网络通信参考模型，按照这个标准使计算机网络系统可以互相连接。
   
   
   
   **物理层：**通过网线、光缆等这种物理方式将电脑连接起来。传递的数据是比特流，0101010100。
   
   
   
   **数据链路层：**首先，把比特流封装成数据帧的格式，对0、1进行分组。电脑连接起来之后，数据都经过网卡来传输，而网卡上定义了全世界唯一的MAC地址。然后再通过广播的形式向局域网内所有电脑发送数据，再根据数据中MAC地址和自身对比判断是否是发给自己的。
   
   
   
   **网络层：**广播的形式太低效，为了区分哪些MAC地址属于同一个子网，网络层定义了IP和子网掩码，通过对IP和子网掩码进行与运算就知道是否是同一个子网，再通过路由器和交换机进行传输。**IP协议属于网络层的协议**。
   
   
   
   **传输层：**有了网络层的MAC+IP地址之后，为了确定数据包是从哪个进程发送过来的，就需要端口号，通过端口来建立通信，比如**TCP和UDP属于这一层的协议。**
   
   
   
   **会话层：**负责建立和断开连接。
   
   
   
   **表示层：**为了使得数据能够被其他的计算机理解，再次将数据转换成另外一种格式，比如文字、视频、图片等。
   
   
   
   **应用层：**最高层，面对用户，提供计算机网络与最终呈现给用户的界面。
   
   ![OSI七层协议](https://pic2.zhimg.com/80/v2-eb26221e7636d95967865fa08c8409f1_720w.jpg)
   
   TCP/IP则是四层的结构，相当于是对OSI模型的简化。
   
   **数据链路层**，也有称作网络访问层、网络接口层。他包含了OSI模型的物理层和数据链路层，把电脑连接起来。
   
   **网络层**，也叫做IP层，处理IP数据包的传输、路由，建立主机间的通信。
   
   **传输层**，就是为两台主机设备提供端到端的通信。
   
   **应用层**，包含OSI的会话层、表示层和应用层，提供了一些常用的协议规范，比如FTP、SMPT、HTTP等。
   
   
   
   总结下来，就是物理层通过物理手段把电脑连接起来，数据链路层则对比特流的数据进行分组，网络层来建立主机到主机的通信，传输层建立端口到端口的通信，应用层最终负责建立连接，数据格式转换，最终呈现给用户。
   
   [面试题系列：网络篇夺命连环12问](https://zhuanlan.zhihu.com/p/379609476)
   
2. ##### 说说 TCP 3次握手的过程？为什么要3次？2次，4次不行吗？

   建立连接前server端需要监听端口，所以初始状态是LISTEN。

   1.client端建立连接，发送一个SYN同步包，发送之后状态变成SYN_SENT

   2.server端收到SYN之后，同意建立连接，返回一个ACK响应，同时也会给client发送一个SYN包，发送完成之后状态变为SYN_RCVD

   3.client端收到server的ACK之后，状态变为ESTABLISHED，返回ACK给server端。server收到之后状态也变为ESTABLISHED，连接建立完成。

   ![img](https://pic3.zhimg.com/80/v2-04ec17f2fcd20ab7b7c7d0101d0617f2_720w.jpg)

   因为TCP是双工传输模式，不区分客户端和服务端，连接的建立是双向的过程。

   如果只有两次，无法做到双向连接的建立，从建立连接server回复的SYN和ACK合并成一次可以看出来，他也不需要4次。

   挥手为什么要四次？因为挥手的ACK和FIN不能同时发送，因为数据发送的截止时间不同。

   [面试题系列：网络篇夺命连环12问](https://zhuanlan.zhihu.com/p/379609476)

3. ##### 讲一讲TCP协议的三次握手和四次挥手流程

   了解几个东西：

   （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

   （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

   （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

   > （A）URG：紧急指针（urgent pointer）有效。
   >
   > （B）ACK：确认序号有效。
   >
   > （C）PSH：接收方应该尽快将这个报文交给应用层。
   >
   > （D）RST：重置连接。
   >
   > （E）SYN：发起一个新连接。
   >
   > （F）FIN：释放一个连接。

   **需要注意的是：**

   （A）不要将确认序号Ack与标志位中的ACK搞混了。

   （B）确认方Ack=发起方Req+1，两端配对。

   **3次握手过程详解**

   所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：

   ![三次握手](https://pic2.zhimg.com/80/v2-b18ec5b3d6e895c15ef46b353f085769_720w.png)

   **（1）第一次握手：**

   Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

   **（2）第二次握手：**

   Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

   **（3）第三次握手：**

   Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

   **4次挥手过程详解**

   三次握手耳熟能详，四次挥手估计就少有人知道了。所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

   ![四次挥手](https://pic4.zhimg.com/80/v2-c6d70b9f08ae74a2cde80cb6f3eb849b_720w.png)

   由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

   **第一次挥手：**

   Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

   **第二次挥手：**

   Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

   **第三次挥手：**

   Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

   **第四次挥手：**

   Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

   [理论经典：TCP协议的3次握手与4次挥手过程详解](https://zhuanlan.zhihu.com/p/22639051)

4. ##### 从输入url地址到页面相应都发生了什么？

   简单版：

   1. 浏览器的地址栏输入URL并按下回车。
   2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
   3. DNS解析URL对应的IP。
   4. 根据IP建立TCP连接（三次握手）。
   5. HTTP发起请求。
   6. 服务器处理请求，浏览器接收HTTP响应。
   7. 渲染页面，构建DOM树。
   8. 关闭TCP连接（四次挥手）

   详细版：

   （1）**解析URL：** 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

   （2）**缓存判断：** 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

   （3）**DNS解析：** 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

   （4）**获取MAC地址：** 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

   （5）**TCP三次握手：** 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

   （6）**HTTPS握手：** 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

   （7）**返回数据：** 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

   （8）**页面渲染：** 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

   （9）**TCP四次挥手：** 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

   [当在浏览器中输入 Google.com 并且按下回车之后发生了什么？](https://juejin.cn/post/6908327746473033741#heading-12)

5. ##### TCP 怎么保证传输过程的可靠性？

   **校验和：**发送方在发送数据之前计算校验和，接收方收到数据后同样计算，如果不一致，那么传输有误。

   **确认应答，序列号：**TCP进行传输时数据都进行了编号，每次接收方返回ACK都有确认序列号。

   **超时重传：**如果发送方发送数据一段时间后没有收到ACK，那么就重发数据。

   **连接管理：**三次握手和四次挥手的过程。

   **流量控制：**TCP协议报头包含16位的窗口大小，接收方会在返回ACK时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度。

   **拥塞控制：**刚开始发送数据的时候，拥塞窗口是1，以后每次收到ACK，则拥塞窗口+1，然后将拥塞窗口和收到的窗口取较小值作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为1。这样做的目的就是为了保证传输过程的高效性和可靠性。

   [理论经典：TCP协议的3次握手与4次挥手过程详解](https://zhuanlan.zhihu.com/p/22639051)

6. 



### 其他

1. ##### 了解Base64编码吗？

   **「Base64」** 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 **「2⁶ = 64」** ，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。相应的转换过程如下图所示：
   
   ![img](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca09794438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   
   **「Base64 常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。」** 在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。
   
   Base64 相应的索引表如下：
   
   ![img](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca54b1a453?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   
   了解完上述的知识，我们以编码 `Man` 为例，来直观的感受一下编码过程。`Man` 由 M、a 和 n 这 3 个字符组成，它们对应的 ASCII 码为 77、97 和 110。
   
   ![img](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca5f44a549?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   
   接着我们以每 6 个比特为一个单元，进行 base64 编码操作，具体如下图所示：
   
   ![img](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca37281c2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   
   由图可知，`Man` （3 字节）编码的结果为 `TWFu`（4 字节），很明显经过 base64 编码后体积会增加 1/3。`Man` 这个字符串的长度刚好是 3，我们可以用 4 个 base64 单元来表示。但如果待编码的字符串长度不是 3 的整数倍时，应该如何处理呢？
   
   **「如果要编码的字节数不能被 3 整除，最后会多出 1 个或 2 个字节，那么可以使用下面的方法进行处理：先使用 0 字节值在末尾补足，使其能够被 3 整除，然后再进行 base64 的编码。」**
   
   以编码字符 A 为例，其所占的字节数为 1，不能被 3 整除，需要补 2 个字节，具体如下图所示：
   
   ![img](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca7b3ae359?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   
   由上图可知，字符 A 经过 base64 编码后的结果是 `QQ==`，该结果后面的两个 `=` 代表补足的字节数。而最后个 1 个 base64 字节块有 4 位是 0 值。
   
   接着我们来看另一个示例，假设需编码的字符串为 `BC`，其所占字节数为 2，不能被 3 整除，需要补 1 个字节，具体如下图所示：
   
   ![img](https://user-gold-cdn.xitu.io/2020/7/5/1731f4ca9206c686?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
   
   由上图可知，字符串 BC 经过 base64 编码后的结果是 `QkM=`，该结果后面的 1 个 `=` 代表补足的字节数。而最后个 1 个 base64 字节块有 2 位是 0 值。
   
   在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串：
   
   - btoa()：该函数能够基于二进制数据 “字符串” 创建一个 base64 编码的 ASCII 字符串。
   - atob()： 该函数能够解码通过 base64 编码的字符串数据。
   
   ##### 1.2.1 btoa 使用示例
   
   ```
   const name = 'Semlinker';
   const encodedName = btoa(name);
   console.log(encodedName); // U2VtbGlua2Vy
   复制代码
   ```
   
   ##### 1.2.2 atob 使用示例
   
   ```
   const encodedName = 'U2VtbGlua2Vy';
   const name = atob(encodedName);
   console.log(name); // Semlinker
   复制代码
   ```
   
   对于 atob 和 btoa 这两个方法来说，其中的 a 代表 ASCII，而 b 代表 Blob，即二进制。因此 atob 表示 ASCII 到二进制，对应的是解码操作。而 btoa 表示二进制到 ASCII，对应的是编码操作。在了解方法中 a 和 b 分别代表的意义之后，在以后的工作中，我们就不会用错了。
   
   相信看到这里，小伙伴们对 base64 已经有一定的了解。需要注意的是 base64 只是一种数据编码方式，目的是为了保障数据的安全传输。但标准的 base64 编码无需额外的信息，即可以进行解码，是完全可逆的。因此在涉及传输私密数据时，并不能直接使用 base64 编码，而是要使用专门的对称或非对称加密算法。
   
2. ##### MVVM、MVC、MVP的区别

   

